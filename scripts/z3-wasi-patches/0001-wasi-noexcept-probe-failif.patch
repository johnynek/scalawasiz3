--- a/src/tactic/probe.cpp
+++ b/src/tactic/probe.cpp
@@ -245,18 +245,30 @@
 
 probe * mk_div(probe * p1, probe * p2) {
     return alloc(div_probe, p1, p2);
+}
+
+template<typename Predicate>
+static bool test_without_exceptions(goal const & g, Predicate & p) {
+    for_each_expr_at(p, g);
+    return p.m_found;
 }
 
 struct is_non_propositional_predicate {
     struct found : public std::exception {};
     ast_manager & m;
-
-    is_non_propositional_predicate(ast_manager & _m):m(_m) {}
-    void operator()(var *) { throw found();  }
-    void operator()(quantifier *) { throw found(); }
+    bool          m_found;
+
+    is_non_propositional_predicate(ast_manager & _m):m(_m), m_found(false) {}
+
+    void mark_found() { m_found = true; }
+
+    void operator()(var *) { mark_found(); }
+    void operator()(quantifier *) { mark_found(); }
     void operator()(app * n) {
+        if (m_found)
+            return;
         if (!m.is_bool(n))
-            throw found();
+            mark_found();
 
         family_id fid = n->get_family_id();
         if (fid == m.get_basic_family_id())
@@ -265,7 +277,7 @@
         if (is_uninterp_const(n))
             return;
 
-        throw found();
+        mark_found();
     }
 };
 
@@ -273,16 +285,21 @@
     struct found : public std::exception {};
     ast_manager & m;
     bv_util       u;
+    bool          m_found;
 
-    is_non_qfbv_predicate(ast_manager & _m):m(_m), u(m) {}
+    is_non_qfbv_predicate(ast_manager & _m):m(_m), u(m), m_found(false) {}
 
-    void operator()(var *) { throw found();  }
+    void mark_found() { m_found = true; }
 
-    void operator()(quantifier *) { throw found(); }
+    void operator()(var *) { mark_found(); }
 
+    void operator()(quantifier *) { mark_found(); }
+
     void operator()(app * n) {
+        if (m_found)
+            return;
         if (!m.is_bool(n) && !u.is_bv(n))
-            throw found();
+            mark_found();
         family_id fid = n->get_family_id();
         if (fid == m.get_basic_family_id())
             return;
@@ -292,19 +309,20 @@
                 n->get_decl_kind() == OP_BSREM0 ||
                 n->get_decl_kind() == OP_BUREM0 ||
                 n->get_decl_kind() == OP_BSMOD0)
-                throw found();
+                mark_found();
             return;
         }
         if (is_uninterp_const(n))
             return;
-        throw found();
+        mark_found();
     }
 };
 
 class is_propositional_probe : public probe {
 public:
     result operator()(goal const & g) override {
-        return !test<is_non_propositional_predicate>(g);
+        is_non_propositional_predicate p(g.m());
+        return !test_without_exceptions(g, p);
     }
 };
 
@@ -312,7 +330,8 @@
 class is_qfbv_probe : public probe {
 public:
     result operator()(goal const & g) override {
-        return !test<is_non_qfbv_predicate>(g);
+        is_non_qfbv_predicate p(g.m());
+        return !test_without_exceptions(g, p);
     }
 };
 
@@ -329,16 +348,21 @@
     ast_manager & m;
     bv_util       m_bv_util;
     array_util    m_array_util;
+    bool          m_found;
 
-    is_non_qfaufbv_predicate(ast_manager & _m) : m(_m), m_bv_util(_m), m_array_util(_m) {}
+    is_non_qfaufbv_predicate(ast_manager & _m) : m(_m), m_bv_util(_m), m_array_util(_m), m_found(false) {}
 
-    void operator()(var *) { throw found(); }
+    void mark_found() { m_found = true; }
 
-    void operator()(quantifier *) { throw found(); }
+    void operator()(var *) { mark_found(); }
 
+    void operator()(quantifier *) { mark_found(); }
+
     void operator()(app * n) {
+        if (m_found)
+            return;
         if (!m.is_bool(n) && !m_bv_util.is_bv(n) && !m_array_util.is_array(n))
-            throw found();
+            mark_found();
         family_id fid = n->get_family_id();
         if (fid == m.get_basic_family_id())
             return;
@@ -347,14 +371,15 @@
         if (is_uninterp(n))
             return;
 
-        throw found();
+        mark_found();
     }
 };
 
 class is_qfaufbv_probe : public probe {
 public:
     result operator()(goal const & g) override {
-        return !test<is_non_qfaufbv_predicate>(g);
+        is_non_qfaufbv_predicate p(g.m());
+        return !test_without_exceptions(g, p);
     }
 };
 
@@ -367,16 +392,21 @@
     struct found : public std::exception {};
     ast_manager & m;
     bv_util       m_bv_util;
+    bool          m_found;
 
-    is_non_qfufbv_predicate(ast_manager & _m) : m(_m), m_bv_util(_m) {}
+    is_non_qfufbv_predicate(ast_manager & _m) : m(_m), m_bv_util(_m), m_found(false) {}
 
-    void operator()(var *) { throw found(); }
+    void mark_found() { m_found = true; }
 
-    void operator()(quantifier *) { throw found(); }
+    void operator()(var *) { mark_found(); }
 
+    void operator()(quantifier *) { mark_found(); }
+
     void operator()(app * n) {
+        if (m_found)
+            return;
         if (!m.is_bool(n) && !m_bv_util.is_bv(n))
-            throw found();
+            mark_found();
         family_id fid = n->get_family_id();
         if (fid == m.get_basic_family_id())
             return;
@@ -385,14 +415,15 @@
         if (is_uninterp(n))
             return;
 
-        throw found();
+        mark_found();
     }
 };
 
 class is_qfufbv_probe : public probe {
 public:
     result operator()(goal const & g) override {
-        return !test<is_non_qfufbv_predicate>(g);
+        is_non_qfufbv_predicate p(g.m());
+        return !test_without_exceptions(g, p);
     }
 };
 
@@ -506,27 +537,21 @@
     struct found : public std::exception {};
 
     struct proc {
+        bool & m_found;
+        proc(bool & found):m_found(found) {}
         void operator()(var * n) {}
         void operator()(app * n) {}
         void operator()(quantifier * n) {
             if (n->get_num_patterns() > 0 || n->get_num_no_patterns() > 0)
-                throw found();
+                m_found = true;
         }
     };
 public:
     result operator()(goal const & g) override {
-        try {
-            expr_fast_mark1 visited;
-            proc p;
-            unsigned sz = g.size();
-            for (unsigned i = 0; i < sz; ++i) {
-                quick_for_each_expr(p, visited, g.form(i));
-            }
-            return false;
-        }
-        catch (const found &) {
-            return true;
-        }
+        bool found = false;
+        proc p(found);
+        for_each_expr_at(p, g);
+        return found;
     }
 };
 
@@ -539,24 +564,18 @@
     struct found : public std::exception {};
 
     struct proc {
+        bool & m_found;
+        proc(bool & found):m_found(found) {}
         void operator()(var * n) {}
         void operator()(app * n) {}
-        void operator()(quantifier * n) { throw found(); }
+        void operator()(quantifier * n) { m_found = true; }
     };
 public:
     result operator()(goal const & g) override {
-        try {
-            expr_fast_mark1 visited;
-            proc p;
-            unsigned sz = g.size();
-            for (unsigned i = 0; i < sz; ++i) {
-                quick_for_each_expr(p, visited, g.form(i));
-            }
-            return false;
-        }
-        catch (const found &) {
-            return true;
-        }
+        bool found = false;
+        proc p(found);
+        for_each_expr_at(p, g);
+        return found;
     }
 };
 
@@ -565,4 +584,3 @@
 }
 
 
-
--- a/src/tactic/arith/probe_arith.cpp
+++ b/src/tactic/arith/probe_arith.cpp
@@ -24,6 +24,12 @@
 
 namespace {
 
+template<typename Predicate>
+static bool test_without_exceptions(goal const & g, Predicate & p) {
+    for_each_expr_at(p, g);
+    return p.m_found;
+}
+
 class arith_degree_probe : public probe {
     struct proc {
         ast_manager &            m;
@@ -133,11 +139,12 @@
     struct found : public std::exception {};
     ast_manager& m;
     arith_util   a;
-    has_nlmul(ast_manager& m):m(m), a(m) {}
+    bool         m_found;
+    has_nlmul(ast_manager& m):m(m), a(m), m_found(false) {}
     
     void throw_found(expr* e) {
+        m_found = true;
         TRACE(probe, tout << expr_ref(e, m) << ": " << sort_ref(e->get_sort(), m) << "\n";);
-        throw found();
     }
 
     void operator()(var *) { }
@@ -145,6 +152,8 @@
     void operator()(quantifier *) { }
 
     void operator()(app * n) {
+        if (m_found)
+            return;
         family_id fid = n->get_family_id();
         if (fid == a.get_family_id()) {
             switch (n->get_decl_kind()) {
@@ -190,12 +199,15 @@
     arith_util    u;
     bool          m_int;
     bool          m_real;
+    bool          m_found;
 
-    is_non_qflira_functor(ast_manager & _m, bool _int, bool _real):m(_m), u(m), m_int(_int), m_real(_real) {}
+    is_non_qflira_functor(ast_manager & _m, bool _int, bool _real):m(_m), u(m), m_int(_int), m_real(_real), m_found(false) {}
 
-    void operator()(var *) { throw found();  }
+    void mark_found() { m_found = true; }
+
+    void operator()(var *) { mark_found();  }
     
-    void operator()(quantifier *) { throw found(); }
+    void operator()(quantifier *) { mark_found(); }
     
     bool compatible_sort(app * n) const {
         if (m.is_bool(n))
@@ -208,8 +220,10 @@
     }
 
     void operator()(app * n) {
+        if (m_found)
+            return;
         if (!compatible_sort(n))
-            throw found();
+            mark_found();
         family_id fid = n->get_family_id();
         if (fid == m.get_basic_family_id())
             return; 
@@ -220,22 +234,22 @@
                 return;
             case OP_MUL:
                 if (n->get_num_args() != 2)
-                    throw found();
+                    mark_found();
                 if (!u.is_numeral(n->get_arg(0)))
-                    throw found();
+                    mark_found();
                 return;
             case OP_TO_REAL:
                 if (!m_real)
-                    throw found();
+                    mark_found();
                 break;
             default:
-                throw found();
+                mark_found();
             }
             return;
         }
         if (is_uninterp_const(n))
             return;
-        throw found();
+        mark_found();
     }
 };
 
@@ -246,14 +260,17 @@
     array_util    m_array_util;
     bool          m_int;
     bool          m_real;
+    bool          m_found;
 
     is_non_qfauflira_functor(ast_manager & _m, bool _int, bool _real) : 
-        m(_m), m_arith_util(_m), m_array_util(_m), m_int(_int), m_real(_real) {}
+        m(_m), m_arith_util(_m), m_array_util(_m), m_int(_int), m_real(_real), m_found(false) {}
 
-    void operator()(var *) { throw found(); }
+    void mark_found() { m_found = true; }
 
-    void operator()(quantifier *) { throw found(); }
+    void operator()(var *) { mark_found(); }
 
+    void operator()(quantifier *) { mark_found(); }
+
     bool compatible_sort(app * n) const {
         if (m.is_bool(n))
             return true;
@@ -267,8 +284,10 @@
     }
 
     void operator()(app * n) {
+        if (m_found)
+            return;
         if (!compatible_sort(n))
-            throw found();
+            mark_found();
         family_id fid = n->get_family_id();
         if (fid == m.get_basic_family_id())
             return;
@@ -279,33 +298,33 @@
                 return;
             case OP_MUL:
                 if (n->get_num_args() != 2)
-                    throw found();
+                    mark_found();
                 if (!m_arith_util.is_numeral(n->get_arg(0)))
-                    throw found();
+                    mark_found();
                 return;
             case OP_TO_REAL:
                 if (!m_real)
-                    throw found();
+                    mark_found();
                 break;
             default:
-                throw found();
+                mark_found();
             }
             return;
         }
         if (is_uninterp(n))
             return;
-        throw found();
+        mark_found();
     }
 };
 
 static bool is_qflia(goal const & g) {
     is_non_qflira_functor p(g.m(), true, false);
-    return !test(g, p);
+    return !test_without_exceptions(g, p);
 }
 
 static bool is_qfauflia(goal const & g) {
     is_non_qfauflira_functor p(g.m(), true, false);
-    return !test(g, p);
+    return !test_without_exceptions(g, p);
 }
 
 class is_qflia_probe : public probe {
@@ -324,7 +343,7 @@
 
 static bool is_qflra(goal const & g) {
     is_non_qflira_functor p(g.m(), false, true);
-    return !test(g, p);
+    return !test_without_exceptions(g, p);
 }
 
 class is_qflra_probe : public probe {
@@ -336,7 +355,7 @@
 
 static bool is_qflira(goal const & g) {
     is_non_qflira_functor p(g.m(), true, true);
-    return !test(g, p);
+    return !test_without_exceptions(g, p);
 }
 
 class is_qflira_probe : public probe {
@@ -434,12 +453,13 @@
     bool          m_real;
     bool          m_quant;
     bool          m_linear;
+    bool          m_found;
 
-    is_non_nira_functor(ast_manager & _m, bool _int, bool _real, bool _quant, bool linear):m(_m), u(m), m_int(_int), m_real(_real), m_quant(_quant), m_linear(linear) {}
+    is_non_nira_functor(ast_manager & _m, bool _int, bool _real, bool _quant, bool linear):m(_m), u(m), m_int(_int), m_real(_real), m_quant(_quant), m_linear(linear), m_found(false) {}
 
     void throw_found(expr* e) {
+        m_found = true;
         TRACE(probe, tout << expr_ref(e, m) << ": " << sort_ref(e->get_sort(), m) << "\n";);
-        throw found();
     }
 
     void operator()(var * x) {
@@ -471,6 +491,8 @@
     }
 
     void operator()(app * n) {
+        if (m_found)
+            return;
         if (!compatible_sort(n))
             throw_found(n);
         family_id fid = n->get_family_id();
@@ -532,42 +554,47 @@
 
 static bool is_qfnia(goal const & g) {
     is_non_nira_functor p(g.m(), true, false, false, false);
-    return !test(g, p) && test<has_nlmul>(g);
+    has_nlmul nl(g.m());
+    return !test_without_exceptions(g, p) && test_without_exceptions(g, nl);
 }
 
 static bool is_qfnra(goal const & g) {
     is_non_nira_functor p(g.m(), false, true, false, false);
-    return !test(g, p) && test<has_nlmul>(g);
+    has_nlmul nl(g.m());
+    return !test_without_exceptions(g, p) && test_without_exceptions(g, nl);
 }
 
 static bool is_nia(goal const & g) {
     is_non_nira_functor p(g.m(), true, false, true, false);
-    return !test(g, p) && test<has_nlmul>(g);
+    has_nlmul nl(g.m());
+    return !test_without_exceptions(g, p) && test_without_exceptions(g, nl);
 }
 
 static bool is_nra(goal const & g) {
     is_non_nira_functor p(g.m(), false, true, true, false);
-    return !test(g, p) && test<has_nlmul>(g);
+    has_nlmul nl(g.m());
+    return !test_without_exceptions(g, p) && test_without_exceptions(g, nl);
 }
 
 static bool is_nira(goal const & g) {
     is_non_nira_functor p(g.m(), true, true, true, false);
-    return !test(g, p) && test<has_nlmul>(g);
+    has_nlmul nl(g.m());
+    return !test_without_exceptions(g, p) && test_without_exceptions(g, nl);
 }
 
 static bool is_lra(goal const & g) {
     is_non_nira_functor p(g.m(), false, true, true, true);
-    return !test(g, p);
+    return !test_without_exceptions(g, p);
 }
 
 static bool is_lia(goal const & g) {
     is_non_nira_functor p(g.m(), true, false, true, true);
-    return !test(g, p);
+    return !test_without_exceptions(g, p);
 }
 
 static bool is_lira(goal const & g) {
     is_non_nira_functor p(g.m(), true, true, true, true);
-    return !test(g, p);
+    return !test_without_exceptions(g, p);
 }
 
 
@@ -576,12 +603,13 @@
     ast_manager & m;
     arith_util    u;
     bool          m_has_nonlinear;
+    bool          m_found;
 
     is_non_qfufnra_functor(ast_manager & _m): 
-        m(_m), u(m), m_has_nonlinear(false) {}
+        m(_m), u(m), m_has_nonlinear(false), m_found(false) {}
 
     void throw_found() {
-        throw found();
+        m_found = true;
     }
 
     bool has_nonlinear() const {
@@ -595,6 +623,8 @@
         throw_found(); 
     }    
     void operator()(app * n) {
+        if (m_found)
+            return;
         family_id fid = n->get_family_id();
         if (fid == m.get_basic_family_id())
             return; 
@@ -698,7 +728,7 @@
 
 static bool is_qfufnra(goal const& g) {
     is_non_qfufnra_functor p(g.m());
-    return !g.proofs_enabled() && !g.unsat_core_enabled() && !test(g, p) && p.has_nonlinear();
+    return !g.proofs_enabled() && !g.unsat_core_enabled() && !test_without_exceptions(g, p) && p.has_nonlinear();
 }
 
 class is_qfufnra_probe : public probe {
--- a/src/tactic/arith/add_bounds_tactic.cpp
+++ b/src/tactic/arith/add_bounds_tactic.cpp
@@ -25,12 +25,15 @@
     struct found : public std::exception {};
     arith_util      m_util;
     bound_manager & m_bm;
+    bool            m_found;
     
-    is_unbounded_proc(bound_manager & bm):m_util(bm.m()), m_bm(bm) {}
+    is_unbounded_proc(bound_manager & bm):m_util(bm.m()), m_bm(bm), m_found(false) {}
 
     void operator()(app * t) {
+        if (m_found)
+            return;
         if (is_uninterp_const(t) &&  (m_util.is_int(t) || m_util.is_real(t)) && (!m_bm.has_lower(t) || !m_bm.has_upper(t)))
-            throw found();
+            m_found = true;
     }
     
     void operator()(var *) {}
@@ -44,7 +47,8 @@
     for (auto [f, d, p] : g)
         bm(f, d, p);
     is_unbounded_proc proc(bm);
-    return test(g, proc);
+    for_each_expr_at(proc, g);
+    return proc.m_found;
 }
 
 class is_unbounded_probe : public probe {
--- a/src/tactic/goal_util.cpp
+++ b/src/tactic/goal_util.cpp
@@ -22,12 +22,20 @@
 struct has_term_ite_functor {
     struct found : public std::exception {};
     ast_manager & m;
-    has_term_ite_functor(ast_manager & _m):m(_m) {}
+    bool          m_found;
+    has_term_ite_functor(ast_manager & _m):m(_m), m_found(false) {}
     void operator()(var *) {}
     void operator()(quantifier *) {}
-    void operator()(app * n) { if (m.is_term_ite(n)) throw found(); }
+    void operator()(app * n) {
+        if (m_found)
+            return;
+        if (m.is_term_ite(n))
+            m_found = true;
+    }
 };
 
 bool has_term_ite(goal const & g) {
-    return test<has_term_ite_functor>(g);
+    has_term_ite_functor p(g.m());
+    for_each_expr_at(p, g);
+    return p.m_found;
 }
--- a/src/tactic/tactical.cpp
+++ b/src/tactic/tactical.cpp
@@ -117,7 +117,10 @@
         goal_ref_buffer r1;
         m_t1->operator()(in, r1);
         unsigned r1_size = r1.size();                                                                       
-        SASSERT(r1_size > 0);  
+        if (r1_size == 0) {
+            result.reset();
+            return;
+        }
         if (r1_size == 1) {                                                                                 
             if (r1[0]->is_decided()) {
                 result.push_back(r1[0]);
@@ -353,7 +356,12 @@
             if (i < sz - 1) {
                 try {
                     t->operator()(in, result);
-                    return;
+                    if (result.empty()) {
+                        result.reset();
+                    }
+                    else {
+                        return;
+                    }
                 }
                 catch (tactic_exception &) {
                     result.reset();
@@ -632,7 +640,10 @@
         goal_ref_buffer r1;
         m_t1->operator()(in, r1);                
         unsigned r1_size = r1.size();                                                                               
-        SASSERT(r1_size > 0);                                                                               
+        if (r1_size == 0) {
+            result.reset();
+            return;
+        }
         if (r1_size == 1) {                                                                                 
             // Only one subgoal created... no need for parallelism
             if (r1[0]->is_decided()) {
@@ -928,7 +939,10 @@
             }
         }
         r1_size = r1.size();                                                                       
-        SASSERT(r1_size > 0);    
+        if (r1_size == 0) {
+            result.reset();
+            return;
+        }
         if (r1_size == 1) {                                                                                 
             if (r1[0]->is_decided()) {
                 result.push_back(r1[0]);  
@@ -1010,7 +1024,7 @@
         m_t->operator()(in, result);
         if (result.size() > m_threshold) {
             result.reset(); // assumes in is not strenthened to one of the branches
-            throw tactic_exception("failed-if-branching tactical");
+            return;
         }
     };    
 
@@ -1190,7 +1204,8 @@
 
     void  operator()(goal_ref const & in, goal_ref_buffer& result) override {
         if (m_p->operator()(*(in.get())).is_true()) {
-            throw tactic_exception("fail-if tactic");
+            result.reset();
+            return;
         }
         result.push_back(in.get());
     }
@@ -1284,4 +1299,3 @@
 tactic * skip_if_failed(tactic * t) {
     return or_else(t, mk_skip_tactic());
 }
-
